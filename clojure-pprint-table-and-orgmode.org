#+TITLE: clojure.pprint/print-table and Emacs org-mode
#+AUTHOR: jherrlin@gmail.com

* Abstract

  Simple use of clojure.pprint/print-table and org-mode.

* print-table and org-mode

  Emacs and Clojure is a match made in heaven!

  Bellow is a org-mode table.

  #+BEGIN_SRC org
    ,#+NAME: heroku-apps
    | Heroku app name | AWS MongoDB host                                     |
    |-----------------+------------------------------------------------------|
    | customer1-stage | lyvyprpzxhpcmgmnccou.eu-west-1.compute.amazonaws.com |
    | customer1-prod  | jnlwdavhxhmmhtemxcwf.eu-west-1.compute.amazonaws.com |
    | customer2-stage | lyvyprpzxhpcmgmnccou.eu-west-1.compute.amazonaws.com |
    | customer2-prod  | jnlwdavhxhmmhtemxcwf.eu-west-1.compute.amazonaws.com |
    | customer3-stage | lyvyprpzxhpcmgmnccou.eu-west-1.compute.amazonaws.com |
    | customer3-prod  | jnlwdavhxhmmhtemxcwf.eu-west-1.compute.amazonaws.com |

  #+END_SRC

  We can access that table as a variable in Clojure. Here we convert the table to a vector
  with hash-maps inside. All the hash-maps have equal keys.

  #+BEGIN_SRC org
    ,#+BEGIN_SRC clojure :var ORGTABLE=heroku-apps :results output code
      (->> ORGTABLE
           (reduce #(conj %1 {:heroku-app-name (first %2)
                              :db-host (last %2)}) []))
    ,#+END_SRC
  #+END_SRC

  Here is the result:

  #+RESULTS:
  #+begin_src clojure
  [{:heroku-app-name "customer1-stage",
    :db-host "lyvyprpzxhpcmgmnccou.eu-west-1.compute.amazonaws.com"}
   {:heroku-app-name "customer1-prod",
    :db-host "jnlwdavhxhmmhtemxcwf.eu-west-1.compute.amazonaws.com"}
   {:heroku-app-name "customer2-stage",
    :db-host "lyvyprpzxhpcmgmnccou.eu-west-1.compute.amazonaws.com"}
   {:heroku-app-name "customer2-prod",
    :db-host "jnlwdavhxhmmhtemxcwf.eu-west-1.compute.amazonaws.com"}
   {:heroku-app-name "customer3-stage",
    :db-host "lyvyprpzxhpcmgmnccou.eu-west-1.compute.amazonaws.com"}
   {:heroku-app-name "customer3-prod",
    :db-host "jnlwdavhxhmmhtemxcwf.eu-west-1.compute.amazonaws.com"}]
  #+end_src

  The result can be used as argument to =clojure.pprint/print-table=.

  #+BEGIN_SRC org
    ,#+BEGIN_SRC clojure :results output code
      (clojure.pprint/print-table
       [{:heroku-app-name "customer1-stage"
         :db-host "lyvyprpzxhpcmgmnccou.eu-west-1.compute.amazonaws.com"}
        {:heroku-app-name "customer1-prod"
         :db-host "jnlwdavhxhmmhtemxcwf.eu-west-1.compute.amazonaws.com"}
        {:heroku-app-name "customer2-stage"
         :db-host "lyvyprpzxhpcmgmnccou.eu-west-1.compute.amazonaws.com"}
        {:heroku-app-name "customer2-prod"
         :db-host "jnlwdavhxhmmhtemxcwf.eu-west-1.compute.amazonaws.com"}
        {:heroku-app-name "customer3-stage"
         :db-host "lyvyprpzxhpcmgmnccou.eu-west-1.compute.amazonaws.com"}
        {:heroku-app-name "customer3-prod"
         :db-host "jnlwdavhxhmmhtemxcwf.eu-west-1.compute.amazonaws.com"}])
    ,#+END_SRC
  #+END_SRC

  And voila, here we are back with a valid org-mode table.

  #+RESULTS:
  #+begin_src clojure

| :heroku-app-name |                                             :db-host |
|------------------+------------------------------------------------------|
|  customer1-stage | lyvyprpzxhpcmgmnccou.eu-west-1.compute.amazonaws.com |
|   customer1-prod | jnlwdavhxhmmhtemxcwf.eu-west-1.compute.amazonaws.com |
|  customer2-stage | lyvyprpzxhpcmgmnccou.eu-west-1.compute.amazonaws.com |
|   customer2-prod | jnlwdavhxhmmhtemxcwf.eu-west-1.compute.amazonaws.com |
|  customer3-stage | lyvyprpzxhpcmgmnccou.eu-west-1.compute.amazonaws.com |
|   customer3-prod | jnlwdavhxhmmhtemxcwf.eu-west-1.compute.amazonaws.com |
nil
  #+end_src
